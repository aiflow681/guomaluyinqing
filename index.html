<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>海豚冒险 - 穿越深海</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #gameCanvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
            touch-action: none;
        }
        
        .ui-overlay {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }
        
        .score-display {
            top: 30px;
            right: 30px;
            font-size: 3rem;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            font-weight: bold;
        }
        
        .game-over-screen {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 20, 40, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }
        
        .game-over-screen.active { display: flex; }
        
        .restart-btn {
            padding: 25px 60px;
            font-size: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            transition: transform 0.2s;
        }
        
        .restart-btn:hover { transform: scale(1.05); }
        
        .controls-panel {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: all;
        }
        
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 70px);
            grid-template-rows: repeat(2, 70px);
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(0, 150, 255, 0.7);
            border: 3px solid #00ffff;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s;
        }
        
        .control-btn:active { 
            background: rgba(0, 200, 255, 0.9);
            transform: scale(0.95);
        }
        
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-down { grid-column: 2; grid-row: 2; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay score-display" id="scoreText">0</div>
    
    <div class="ui-overlay game-over-screen" id="gameOverPanel">
        <button class="restart-btn" id="restartBtn">重新开始</button>
    </div>
    
    <div class="ui-overlay controls-panel">
        <div class="btn-grid">
            <button class="control-btn btn-up" data-dir="up">↑</button>
            <button class="control-btn btn-left" data-dir="left">←</button>
            <button class="control-btn btn-down" data-dir="down">↓</button>
            <button class="control-btn btn-right" data-dir="right">→</button>
        </div>
    </div>

    <script src="https://repo.bfw.wiki/bfwrepo/js/three.92.js"></script>
    <script>
        // ========== 游戏配置模块 ==========
        const CONFIG = {
            world: {
                tileSize: 42,
                numColumns: 17,
                scaleFactor: 2,
                viewDistance: 500
            },
            player: {
                size: 15,
                moveSpeed: 200
            },
            obstacles: {
                types: ['smallFish', 'shark', 'coral'],
                speeds: [2, 2.5, 3],
                coralHeights: [20, 45, 60]
            },
            colors: {
                ocean: {
                    deep: 0x001a33,
                    mid: 0x003d66,
                    light: 0x006699
                },
                creatures: {
                    fish: [0xffa500, 0xff6347, 0xff1493, 0x00ced1],
                    shark: [0x708090, 0x2f4f4f, 0x696969],
                    coral: [0xff69b4, 0xffa500, 0x9370db]
                },
                path: {
                    main: 0x1e90ff,
                    side: 0x4169e1
                },
                ground: {
                    main: 0xff7f50,
                    side: 0xff6347
                }
            }
        };

        // ========== 工具函数模块 ==========
        const Utils = {
            randomChoice: (arr) => arr[Math.floor(Math.random() * arr.length)],
            randomInt: (max) => Math.floor(Math.random() * max),
            randomBool: () => Math.random() >= 0.5,
            clamp: (val, min, max) => Math.max(min, Math.min(max, val))
        };

        // ========== 场景管理器 ==========
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.colors.ocean.deep);
                this.setupCamera();
                this.setupRenderer();
                this.setupLighting();
            }

            setupCamera() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                this.camera = new THREE.OrthographicCamera(w/-2, w/2, h/2, h/-2, 0.1, 10000);
                
                const angleX = 50 * Math.PI / 180;
                const angleY = 20 * Math.PI / 180;
                const angleZ = 10 * Math.PI / 180;
                
                this.camera.rotation.set(angleX, angleY, angleZ);
                
                const dist = CONFIG.world.viewDistance;
                const camY = -Math.tan(angleX) * dist;
                const camX = Math.tan(angleY) * Math.sqrt(dist**2 + camY**2);
                
                this.camera.position.set(camX, camY, dist);
                this.initialCamPos = { x: camX, y: camY };
            }

            setupRenderer() {
                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas, 
                    alpha: true, 
                    antialias: true 
                });
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            setupLighting() {
                const hemi = new THREE.HemisphereLight(0x87ceeb, 0x006994, 0.6);
                this.scene.add(hemi);

                const dirLight1 = new THREE.DirectionalLight(0xadd8e6, 0.6);
                dirLight1.position.set(-100, -100, 200);
                dirLight1.castShadow = true;
                dirLight1.shadow.mapSize.width = 2048;
                dirLight1.shadow.mapSize.height = 2048;
                const d = 500;
                dirLight1.shadow.camera.left = -d;
                dirLight1.shadow.camera.right = d;
                dirLight1.shadow.camera.top = d;
                dirLight1.shadow.camera.bottom = -d;
                this.scene.add(dirLight1);

                const dirLight2 = new THREE.DirectionalLight(0x4682b4, 0.4);
                dirLight2.position.set(200, 200, 50);
                dirLight2.castShadow = true;
                this.scene.add(dirLight2);
            }

            render() {
                this.renderer.render(this.scene, this.camera);
            }

            addToScene(obj) {
                this.scene.add(obj);
            }

            removeFromScene(obj) {
                this.scene.remove(obj);
            }

            updateCameraPosition(x, y) {
                this.camera.position.x = this.initialCamPos.x + x;
                this.camera.position.y = this.initialCamPos.y + y;
            }
        }

        // ========== 几何体构建器 ==========
        class GeometryBuilder {
            static createBox(w, h, d, color, material = 'phong') {
                const geom = new THREE.BoxBufferGeometry(w, h, d);
                const mat = material === 'phong' 
                    ? new THREE.MeshPhongMaterial({ color, flatShading: true })
                    : new THREE.MeshLambertMaterial({ color, flatShading: true });
                return new THREE.Mesh(geom, mat);
            }

            static createPlane(w, h, color) {
                const geom = new THREE.PlaneBufferGeometry(w, h);
                const mat = new THREE.MeshPhongMaterial({ color });
                return new THREE.Mesh(geom, mat);
            }
        }

        // ========== 玩家角色（海豚）==========
        class DolphinPlayer {
            constructor() {
                this.group = new THREE.Group();
                this.buildModel();
            }

            buildModel() {
                const s = CONFIG.player.size * CONFIG.world.scaleFactor;
                
                // 主体
                const mainBody = GeometryBuilder.createBox(s, 20*CONFIG.world.scaleFactor, 12*CONFIG.world.scaleFactor, 0x708090);
                mainBody.position.z = 8*CONFIG.world.scaleFactor;
                mainBody.castShadow = true;
                mainBody.receiveShadow = true;
                this.group.add(mainBody);

                // 头部
                const headPart = GeometryBuilder.createBox(8*CONFIG.world.scaleFactor, 6*CONFIG.world.scaleFactor, 8*CONFIG.world.scaleFactor, 0x708090);
                headPart.position.y = 13*CONFIG.world.scaleFactor;
                headPart.position.z = 8*CONFIG.world.scaleFactor;
                this.group.add(headPart);

                // 背鳍
                const topFin = GeometryBuilder.createBox(6*CONFIG.world.scaleFactor, 3*CONFIG.world.scaleFactor, 8*CONFIG.world.scaleFactor, 0x5a6d7e, 'lambert');
                topFin.position.z = 16*CONFIG.world.scaleFactor;
                topFin.castShadow = true;
                this.group.add(topFin);

                // 尾鳍
                const tailPart = GeometryBuilder.createBox(12*CONFIG.world.scaleFactor, 3*CONFIG.world.scaleFactor, 2*CONFIG.world.scaleFactor, 0x5a6d7e, 'lambert');
                tailPart.position.y = -10*CONFIG.world.scaleFactor;
                tailPart.position.z = 8*CONFIG.world.scaleFactor;
                this.group.add(tailPart);

                // 腹部
                const bellyPart = GeometryBuilder.createBox(10*CONFIG.world.scaleFactor, 16*CONFIG.world.scaleFactor, 2*CONFIG.world.scaleFactor, 0xb0c4de);
                bellyPart.position.z = 2*CONFIG.world.scaleFactor;
                this.group.add(bellyPart);
            }

            getMesh() {
                return this.group;
            }

            setPosition(x, y, z) {
                this.group.position.set(x, y, z);
            }

            getPosition() {
                return this.group.position;
            }
        }

        // ========== 小鱼障碍物 ==========
        class SmallFishObstacle {
            constructor() {
                this.group = new THREE.Group();
                this.buildModel();
            }

            buildModel() {
                const z = CONFIG.world.scaleFactor;
                const color = Utils.randomChoice(CONFIG.colors.creatures.fish);
                
                const bodyPart = GeometryBuilder.createBox(50*z, 20*z, 18*z, color);
                bodyPart.position.z = 12*z;
                bodyPart.castShadow = true;
                bodyPart.receiveShadow = true;
                this.group.add(bodyPart);
                
                const headPart = GeometryBuilder.createBox(15*z, 12*z, 14*z, color);
                headPart.position.x = 32*z;
                headPart.position.z = 12*z;
                this.group.add(headPart);

                const tailPart = GeometryBuilder.createBox(8*z, 25*z, 3*z, color, 'lambert');
                tailPart.position.x = -29*z;
                tailPart.position.z = 12*z;
                this.group.add(tailPart);
                
                const dorsalPart = GeometryBuilder.createBox(20*z, 4*z, 12*z, color, 'lambert');
                dorsalPart.position.z = 24*z;
                this.group.add(dorsalPart);

                const ventralPart = GeometryBuilder.createBox(15*z, 4*z, 8*z, color, 'lambert');
                ventralPart.position.z = 3*z;
                this.group.add(ventralPart);

                this.group.castShadow = true;
            }

            getMesh() {
                return this.group;
            }
        }

        // ========== 鲨鱼障碍物 ==========
        class SharkObstacle {
            constructor() {
                this.group = new THREE.Group();
                this.buildModel();
            }

            buildModel() {
                const z = CONFIG.world.scaleFactor;
                const color = Utils.randomChoice(CONFIG.colors.creatures.shark);
                
                const bodyPart = GeometryBuilder.createBox(90*z, 30*z, 25*z, color);
                bodyPart.position.z = 15*z;
                bodyPart.castShadow = true;
                bodyPart.receiveShadow = true;
                this.group.add(bodyPart);

                const headPart = GeometryBuilder.createBox(25*z, 20*z, 20*z, color);
                headPart.position.x = 57*z;
                headPart.position.z = 15*z;
                this.group.add(headPart);

                const snoutPart = GeometryBuilder.createBox(15*z, 12*z, 15*z, color);
                snoutPart.position.x = 75*z;
                snoutPart.position.z = 15*z;
                this.group.add(snoutPart);

                const dorsalPart = GeometryBuilder.createBox(25*z, 8*z, 30*z, color, 'lambert');
                dorsalPart.position.x = 10*z;
                dorsalPart.position.z = 40*z;
                this.group.add(dorsalPart);
                
                const tailPart = GeometryBuilder.createBox(12*z, 8*z, 35*z, color, 'lambert');
                tailPart.position.x = -52*z;
                tailPart.position.z = 15*z;
                this.group.add(tailPart);

                const sidePart = GeometryBuilder.createBox(20*z, 15*z, 3*z, color, 'lambert');
                sidePart.position.x = 20*z;
                sidePart.position.z = 5*z;
                this.group.add(sidePart);

                const bellyPart = GeometryBuilder.createBox(70*z, 25*z, 3*z, 0xd3d3d3);
                bellyPart.position.z = 3*z;
                this.group.add(bellyPart);
            }

            getMesh() {
                return this.group;
            }
        }

        // ========== 珊瑚障碍物 ==========
        class CoralObstacle {
            constructor() {
                this.group = new THREE.Group();
                this.buildModel();
            }

            buildModel() {
                const z = CONFIG.world.scaleFactor;
                
                const basePart = GeometryBuilder.createBox(15*z, 15*z, 20*z, 0xff6347);
                basePart.position.z = 10*z;
                basePart.castShadow = true;
                basePart.receiveShadow = true;
                this.group.add(basePart);

                const height = Utils.randomChoice(CONFIG.obstacles.coralHeights);
                const color = Utils.randomChoice(CONFIG.colors.creatures.coral);

                const topPart = GeometryBuilder.createBox(30*z, 30*z, height*z, color, 'lambert');
                topPart.position.z = (height/2 + 20)*z;
                topPart.castShadow = true;
                this.group.add(topPart);
            }

            getMesh() {
                return this.group;
            }
        }

        // ========== 路径/地面构建器 ==========
        class PathBuilder {
            static createOceanPath() {
                const group = new THREE.Group();
                const z = CONFIG.world.scaleFactor;
                const w = CONFIG.world.tileSize * CONFIG.world.numColumns * z;
                const h = CONFIG.world.tileSize * z;

                const centerPart = GeometryBuilder.createPlane(w, h, CONFIG.colors.path.main);
                centerPart.receiveShadow = true;
                group.add(centerPart);

                const leftPart = GeometryBuilder.createPlane(w, h, CONFIG.colors.path.side);
                leftPart.position.x = -w;
                group.add(leftPart);

                const rightPart = GeometryBuilder.createPlane(w, h, CONFIG.colors.path.side);
                rightPart.position.x = w;
                group.add(rightPart);

                return group;
            }

            static createSeaFloor() {
                const group = new THREE.Group();
                const z = CONFIG.world.scaleFactor;
                const w = CONFIG.world.tileSize * CONFIG.world.numColumns * z;
                const h = CONFIG.world.tileSize * z;

                const centerPart = GeometryBuilder.createBox(w, h, 3*z, CONFIG.colors.ground.main);
                centerPart.receiveShadow = true;
                group.add(centerPart);

                const leftPart = GeometryBuilder.createBox(w, h, 3*z, CONFIG.colors.ground.side);
                leftPart.position.x = -w;
                group.add(leftPart);

                const rightPart = GeometryBuilder.createBox(w, h, 3*z, CONFIG.colors.ground.side);
                rightPart.position.x = w;
                group.add(rightPart);

                group.position.z = 1.5*z;
                return group;
            }
        }

        // ========== 泳道管理器 ==========
        class SwimLane {
            constructor(index) {
                this.index = index;
                this.laneType = index <= 0 ? 'safe' : Utils.randomChoice(CONFIG.obstacles.types);
                this.mesh = null;
                this.obstacles = [];
                this.blockedPositions = new Set();
                this.movingDirection = Utils.randomBool();
                this.moveSpeed = Utils.randomChoice(CONFIG.obstacles.speeds);
                
                this.initialize();
            }

            initialize() {
                switch(this.laneType) {
                    case 'safe':
                        this.mesh = PathBuilder.createSeaFloor();
                        break;
                    case 'coral':
                        this.mesh = PathBuilder.createSeaFloor();
                        this.spawnCorals();
                        break;
                    case 'smallFish':
                        this.mesh = PathBuilder.createOceanPath();
                        this.spawnSmallFish();
                        break;
                    case 'shark':
                        this.mesh = PathBuilder.createOceanPath();
                        this.spawnSharks();
                        break;
                }
            }

            spawnCorals() {
                const count = 4;
                for(let i = 0; i < count; i++) {
                    let pos;
                    do {
                        pos = Utils.randomInt(CONFIG.world.numColumns);
                    } while(this.blockedPositions.has(pos));
                    
                    this.blockedPositions.add(pos);
                    const coral = new CoralObstacle();
                    const xPos = this.calculateXPosition(pos);
                    coral.getMesh().position.x = xPos;
                    this.mesh.add(coral.getMesh());
                    this.obstacles.push(coral);
                }
            }

            spawnSmallFish() {
                const count = 3;
                for(let i = 0; i < count; i++) {
                    let pos;
                    do {
                        pos = Utils.randomInt(CONFIG.world.numColumns / 2);
                    } while(this.blockedPositions.has(pos));
                    
                    this.blockedPositions.add(pos);
                    const fish = new SmallFishObstacle();
                    const xPos = this.calculateXPosition(pos * 2);
                    fish.getMesh().position.x = xPos;
                    if(!this.movingDirection) fish.getMesh().rotation.z = Math.PI;
                    this.mesh.add(fish.getMesh());
                    this.obstacles.push(fish);
                }
            }

            spawnSharks() {
                const count = 2;
                for(let i = 0; i < count; i++) {
                    let pos;
                    do {
                        pos = Utils.randomInt(CONFIG.world.numColumns / 3);
                    } while(this.blockedPositions.has(pos));
                    
                    this.blockedPositions.add(pos);
                    const shark = new SharkObstacle();
                    const xPos = this.calculateXPosition(pos * 3);
                    shark.getMesh().position.x = xPos;
                    if(!this.movingDirection) shark.getMesh().rotation.z = Math.PI;
                    this.mesh.add(shark.getMesh());
                    this.obstacles.push(shark);
                }
            }

            calculateXPosition(column) {
                const z = CONFIG.world.scaleFactor;
                const w = CONFIG.world.tileSize;
                const boardW = w * CONFIG.world.numColumns;
                return (column * w + w/2) * z - boardW * z / 2;
            }

            updateMovingObstacles(deltaTime) {
                if(this.laneType !== 'smallFish' && this.laneType !== 'shark') return;

                const z = CONFIG.world.scaleFactor;
                const w = CONFIG.world.tileSize;
                const boardW = w * CONFIG.world.numColumns;
                const leftBound = -boardW * z / 2 - w * 2 * z;
                const rightBound = boardW * z / 2 + w * 2 * z;

                this.obstacles.forEach(obs => {
                    const mesh = obs.getMesh();
                    if(this.movingDirection) {
                        mesh.position.x -= this.moveSpeed / 16 * deltaTime;
                        if(mesh.position.x < leftBound) mesh.position.x = rightBound;
                    } else {
                        mesh.position.x += this.moveSpeed / 16 * deltaTime;
                        if(mesh.position.x > rightBound) mesh.position.x = leftBound;
                    }
                });
            }

            getMesh() {
                return this.mesh;
            }

            hasObstacleAt(column) {
                return this.blockedPositions.has(column);
            }

            checkCollision(playerX, playerSize) {
                if(this.laneType !== 'smallFish' && this.laneType !== 'shark') return false;

                const playerMin = playerX - playerSize / 2;
                const playerMax = playerX + playerSize / 2;
                const obstacleLength = this.laneType === 'smallFish' ? 60 : 105;
                const z = CONFIG.world.scaleFactor;

                for(let obs of this.obstacles) {
                    const mesh = obs.getMesh();
                    const obsMin = mesh.position.x - obstacleLength * z / 2;
                    const obsMax = mesh.position.x + obstacleLength * z / 2;
                    
                    if(playerMax > obsMin && playerMin < obsMax) {
                        return true;
                    }
                }
                return false;
            }
        }

        // ========== 游戏状态管理器 ==========
        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                this.currentRow = 0;
                this.currentCol = Math.floor(CONFIG.world.numColumns / 2);
                this.score = 0;
                this.isMoving = false;
                this.moveQueue = [];
                this.moveStartTime = null;
                this.lastFrameTime = null;
                this.gameOver = false;
            }

            addMove(direction) {
                this.moveQueue.push(direction);
            }

            startMove() {
                this.isMoving = true;
            }

            getNextPosition() {
                if(this.moveQueue.length === 0) return { row: this.currentRow, col: this.currentCol };
                
                return this.moveQueue.reduce((pos, dir) => {
                    switch(dir) {
                        case 'up': return { row: pos.row + 1, col: pos.col };
                        case 'down': return { row: pos.row - 1, col: pos.col };
                        case 'left': return { row: pos.row, col: pos.col - 1 };
                        case 'right': return { row: pos.row, col: pos.col + 1 };
                        default: return pos;
                    }
                }, { row: this.currentRow, col: this.currentCol });
            }

            completeMove(direction) {
                switch(direction) {
                    case 'up':
                        this.currentRow++;
                        this.score = this.currentRow;
                        break;
                    case 'down':
                        this.currentRow--;
                        this.score = this.currentRow;
                        break;
                    case 'left':
                        this.currentCol--;
                        break;
                    case 'right':
                        this.currentCol++;
                        break;
                }
                this.moveQueue.shift();
                this.moveStartTime = this.moveQueue.length === 0 ? null : performance.now();
            }

            triggerGameOver() {
                this.gameOver = true;
            }
        }

        // ========== 主游戏控制器 ==========
        class GameController {
            constructor() {
                this.sceneManager = new SceneManager();
                this.gameState = new GameState();
                this.player = new DolphinPlayer();
                this.lanes = [];
                
                this.initialize();
                this.setupControls();
                this.startGameLoop();
            }

            initialize() {
                this.sceneManager.addToScene(this.player.getMesh());
                this.generateInitialLanes();
                this.updateUI();
            }

            generateInitialLanes() {
                const startIndex = -9;
                const endIndex = 9;
                
                for(let i = startIndex; i <= endIndex; i++) {
                    const lane = new SwimLane(i);
                    const yPos = i * CONFIG.world.tileSize * CONFIG.world.scaleFactor;
                    lane.getMesh().position.y = yPos;
                    this.sceneManager.addToScene(lane.getMesh());
                    
                    if(i >= 0) {
                        this.lanes.push(lane);
                    }
                }
            }

            addNewLane() {
                const index = this.lanes.length;
                const lane = new SwimLane(index);
                const yPos = index * CONFIG.world.tileSize * CONFIG.world.scaleFactor;
                lane.getMesh().position.y = yPos;
                this.sceneManager.addToScene(lane.getMesh());
                this.lanes.push(lane);
            }

            setupControls() {
                // 键盘控制
                window.addEventListener('keydown', (e) => {
                    const keyMap = {
                        38: 'up', 40: 'down', 37: 'left', 39: 'right'
                    };
                    if(keyMap[e.keyCode]) {
                        this.handleMove(keyMap[e.keyCode]);
                    }
                });

                // 按钮控制
                document.querySelectorAll('.control-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.handleMove(btn.dataset.dir);
                    });
                });

                // 重启按钮
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                });
            }

            handleMove(direction) {
                if(this.gameState.gameOver) return;

                const nextPos = this.gameState.getNextPosition();
                
                // 边界检查
                if(direction === 'up') {
                    const targetLane = this.lanes[nextPos.row + 1];
                    if(targetLane && targetLane.laneType === 'coral' && targetLane.hasObstacleAt(nextPos.col)) return;
                    if(!this.gameState.moveStartTime) this.gameState.startMove();
                    this.addNewLane();
                } else if(direction === 'down') {
                    if(nextPos.row === 0) return;
                    const targetLane = this.lanes[nextPos.row - 1];
                    if(targetLane && targetLane.laneType === 'coral' && targetLane.hasObstacleAt(nextPos.col)) return;
                    if(!this.gameState.moveStartTime) this.gameState.startMove();
                } else if(direction === 'left') {
                    if(nextPos.col === 0) return;
                    const targetLane = this.lanes[nextPos.row];
                    if(targetLane && targetLane.laneType === 'coral' && targetLane.hasObstacleAt(nextPos.col - 1)) return;
                    if(!this.gameState.moveStartTime) this.gameState.startMove();
                } else if(direction === 'right') {
                    if(nextPos.col === CONFIG.world.numColumns - 1) return;
                    const targetLane = this.lanes[nextPos.row];
                    if(targetLane && targetLane.laneType === 'coral' && targetLane.hasObstacleAt(nextPos.col + 1)) return;
                    if(!this.gameState.moveStartTime) this.gameState.startMove();
                }

                this.gameState.addMove(direction);
            }

            updatePlayerPosition(timestamp) {
                if(!this.gameState.moveStartTime) return;

                const elapsed = timestamp - this.gameState.moveStartTime;
                const progress = Math.min(elapsed / CONFIG.player.moveSpeed, 1);
                const distance = progress * CONFIG.world.tileSize * CONFIG.world.scaleFactor;
                const jumpHeight = Math.sin(progress * Math.PI) * 8 * CONFIG.world.scaleFactor;

                const currentMove = this.gameState.moveQueue[0];
                const z = CONFIG.world.scaleFactor;
                const w = CONFIG.world.tileSize;
                const boardW = w * CONFIG.world.numColumns;

                switch(currentMove) {
                    case 'up':
                        const upY = this.gameState.currentRow * w * z + distance;
                        this.player.setPosition(this.player.getPosition().x, upY, jumpHeight);
                        // 视角锁定：仅跟随Y轴（前进方向），X轴保持居中
                        this.sceneManager.updateCameraPosition(0, upY);
                        break;
                    case 'down':
                        const downY = this.gameState.currentRow * w * z - distance;
                        this.player.setPosition(this.player.getPosition().x, downY, jumpHeight);
                        this.sceneManager.updateCameraPosition(0, downY);
                        break;
                    case 'left':
                        const leftX = (this.gameState.currentCol * w + w/2) * z - boardW * z / 2 - distance;
                        this.player.setPosition(leftX, this.player.getPosition().y, jumpHeight);
                        // 视角锁定：左右移动时不跟随，保持画面稳定
                        this.sceneManager.updateCameraPosition(0, this.player.getPosition().y);
                        break;
                    case 'right':
                        const rightX = (this.gameState.currentCol * w + w/2) * z - boardW * z / 2 + distance;
                        this.player.setPosition(rightX, this.player.getPosition().y, jumpHeight);
                        this.sceneManager.updateCameraPosition(0, this.player.getPosition().y);
                        break;
                }

                if(elapsed > CONFIG.player.moveSpeed) {
                    this.gameState.completeMove(currentMove);
                    this.updateUI();
                }
            }

            checkCollisions() {
                const currentLane = this.lanes[this.gameState.currentRow];
                if(!currentLane) return;

                const playerX = this.player.getPosition().x;
                const playerSize = CONFIG.player.size * CONFIG.world.scaleFactor;

                if(currentLane.checkCollision(playerX, playerSize)) {
                    this.gameState.triggerGameOver();
                    this.showGameOver();
                }
            }

            updateUI() {
                document.getElementById('scoreText').textContent = this.gameState.score;
            }

            showGameOver() {
                document.getElementById('gameOverPanel').classList.add('active');
            }

            restartGame() {
                // 清理场景
                this.lanes.forEach(lane => {
                    this.sceneManager.removeFromScene(lane.getMesh());
                });
                
                // 重置状态
                this.lanes = [];
                this.gameState.reset();
                this.player.setPosition(0, 0, 0);
                this.sceneManager.updateCameraPosition(0, 0);
                
                // 重新生成
                this.generateInitialLanes();
                this.updateUI();
                document.getElementById('gameOverPanel').classList.remove('active');
            }

            startGameLoop() {
                const animate = (timestamp) => {
                    requestAnimationFrame(animate);

                    if(!this.gameState.lastFrameTime) {
                        this.gameState.lastFrameTime = timestamp;
                    }

                    const deltaTime = timestamp - this.gameState.lastFrameTime;
                    this.gameState.lastFrameTime = timestamp;

                    // 更新移动障碍物
                    this.lanes.forEach(lane => {
                        lane.updateMovingObstacles(deltaTime);
                    });

                    // 开始移动
                    if(this.gameState.isMoving && !this.gameState.moveStartTime) {
                        this.gameState.moveStartTime = timestamp;
                        this.gameState.isMoving = false;
                    }

                    // 更新玩家位置
                    this.updatePlayerPosition(timestamp);

                    // 碰撞检测
                    if(!this.gameState.gameOver) {
                        this.checkCollisions();
                    }

                    // 渲染场景
                    this.sceneManager.render();
                };

                animate(performance.now());
            }
        }

        // ========== 启动游戏 ==========
        window.addEventListener('DOMContentLoaded', () => {
            // 防止双击缩放
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, { passive: false });
            
            // 防止双指缩放
            document.addEventListener('gesturestart', (e) => {
                e.preventDefault();
            });
            
            document.addEventListener('gesturechange', (e) => {
                e.preventDefault();
            });
            
            document.addEventListener('gestureend', (e) => {
                e.preventDefault();
            });
            
            new GameController();
        });
    </script>
</body>
</html>
